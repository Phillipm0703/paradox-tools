#!/usr/bin/env ruby

require_relative "../lib/paradox"

class ListConverterProvinceValue < ParadoxGame
  def province_modifiers
    @province_modifiers ||= begin
      map = {}
      glob("common/event_modifiers/*.txt").each do |path|
        parse(path).each do |name, modifier|
          map[name] = modifier
        end
      end
      map
    end
  end

  def parse_province_file(path)
    # Wanted to do this:
    # parse(path)
    #
    # But due to broken shit in 6-Skane.txt we have to do this:
    content = resolve(path)
      .read
      .force_encoding("windows-1252")
      .encode("utf-8")
      .gsub("add_permanent_province_modifier {", "add_permanent_province_modifier = {")
    ParadoxModFile.new(string: content).parse!
  end

  def merge_modifiers(mods)
    bonus = Hash.new(0)
    mods.each do |name|
      province_modifiers[name].each do |key, val|
        next if key == "picture"
        bonus[key] += val
      end
    end
    bonus
  end

  def price_changes
    @price_changes ||= begin
      # Historical price changes are encoded in
      # history/countries/HAB - Austria.txt
      # but we can grep them all
      map = {}
      glob("history/countries/*.txt").each do |path|
        parse(path).each do |key, val|
          next unless key.is_a?(Date)
          val.find_all("change_price").each do |change|
            raise unless change["duration"] == -1
            good = change["trade_goods"]
            mod = change["value"]
            name = change["key"]
            map[good] ||= []
            map[good] << [key, name, mod]
          end
        end
      end
      map
    end
  end

  def base_prices
    @base_prices ||= begin
      map = Hash.new(0)
      parse("common/prices/00_prices.txt").each do |name, good|
        map[name] = good["base_price"]
      end
      map
    end
  end

  def prices
    @prices ||= begin
      map = base_prices.dup
      price_changes.each do |good, changes|
        average_change = 0
        changes.each do |date, name, value|
          game_part = (1821.0 - date.year) / (1821 - 1444)
          average_change += game_part * value
        end
        map[good] = (map[good] * (1 + average_change)).round(2)
      end
      map
    end
  end


  def provinces
    @provinces ||= begin
      map = {}
      # From average_province script
      base_tax = 2.70
      base_production = 2.72
      base_manpower = 1.85

      # From calculations below
      # It basically simplifies world to one big trade node
      average_trade_power = 3.981490
      average_trade_value = 1.535769
      average_income = 7.181222
      avearge_manpower = base_manpower

      glob("history/provinces/*.txt").each do |path|
        id = path.basename.to_s.to_i
        node = parse_province_file(path)
        name = localization("PROV#{id}")
        mods = node.find_all("add_permanent_province_modifier").map{|mod| mod["name"]}
        bonus = merge_modifiers(mods)
        goods = node["trade_goods"]

        if goods == nil
          next # water or wasetland
        elsif goods == "unknown"
          # Just guess some mid-tier good
          goods_price = prices["fur"]
        else
          goods_price = prices[goods]
        end

        # Dalaskogen's +5 is equivalent to 25 extra dev in this contextgo
        goods_produced = (0.2 * base_production + bonus["trade_goods_size"]).round(6)
        trade_value = goods_produced * goods_price

        # +5% from +1 stab
        # +10% from neutral clergy
        annual_tax = (1.0 * base_tax * 1.15).round(6)

        trade_value = (goods_produced * goods_price).round(6)
        # There are 50% gains from tech, assume middle values
        annual_production = (trade_value * 1.25).round(6)

        base_trade_power = 0.6 * base_production + bonus["province_trade_power_value"]
        # Just guess:
        # * coastal +25%
        # * +50% from 25% mercantilism
        # maybe check what's coastal, then update stuff above
        trade_power = (base_trade_power * 1.75).round(6)

        # There are 50% gains from tech, assume middle values
        annual_trade = (1.25 * average_trade_value * trade_power / average_trade_power).round(6)

        if goods == "gold"
          annual_gold = 6 * base_production
        else
          annual_gold = 0
        end

        annual_income = annual_tax + annual_production + annual_trade + annual_gold

        # Value is based on assumption that 70% of province value is in its income
        # 30% in its base manpower
        value = (0.7 * (annual_income / average_income) + 0.3 * (base_manpower / avearge_manpower)).round(6)

        map[id] = {
          name: name,
          goods: goods,
          bonus: bonus,
          goods_produced: goods_produced,
          goods_price: goods_price,
          trade_value: trade_value,
          base_tax: base_tax,
          base_production: base_production,
          trade_power: trade_power,
          annual_tax: annual_tax,
          annual_production: annual_production,
          annual_trade: annual_trade,
          annual_gold: annual_gold,
          annual_income: annual_income,
          value: value,
        }
      end
      map
    end
  end

  def run!
    provinces.each do |id, province|
      puts "#{id}\t#{province[:value]}"
    end
  end
end

ListConverterProvinceValue.new(*ARGV).run!
