#!/usr/bin/env ruby

require_relative "./eu4_analysis"
require_relative "bonus_scoring"

def bonus_score(bonuses)
  score = BonusScoring.new
  bonuses.each do |k,v|
    score.send(k,v)
  end
  score.score
end

class ReligionGroup
  attr_reader :name, :node
  attr_accessor :religions, :religious_schools

  def initialize(name, node)
    @name = name
    @node = node
    @religions = []
    @religious_schools = nil
  end

  def uses_religious_schools?
    !@religious_schools.empty?
  end

  # Not all are actually pickable, and most countries just start with one
  def each_school_bonus
    @religious_schools.each do |school_name, school|
      bonuses = {}
      school.each do |k, v|
        next if %W[
          potential_invite_scholar
          can_invite_scholar
          on_invite_scholar
          invite_scholar_modifier_display
          picture
        ].include?(k)
        bonuses[k] = v
      end
      yield school_name, bonuses
    end
  end
end

class Religion
  attr_reader :analysis, :group, :name, :node
  attr_accessor :deities

  def initialize(analysis, group, name, node)
    @analysis = analysis
    @group = group
    @name = name
    @node = node
    @deities = {}
    unknown_keys_warning!
  end

  def has_religious_schools?
    @group.uses_religious_schools?
  end

  def uses_piety?
    !!@node["uses_piety"]
  end

  def has_secondary?
    @node["can_have_secondary_religion"]
  end

  def uses_isolationism?
    !!@node["uses_isolationism"]
  end

  def uses_karma?
    !!@node["uses_karma"]
  end

  def has_deities?
    !@deities.empty?
  end

  def fetishist_cult?
    !!@node["fetishist_cult"]
  end

  def aspect_names
    @node["aspects"]
  end

  def uses_aspects?
    !!aspect_names
  end

  def aspects
    @aspects ||= aspect_names.map{|n| [n, @analysis.aspects[n]] }.select{|k,v| v}.to_h
  end

  def blessing_names
    @node["blessings"]
  end

  def uses_blessings?
    !!blessing_names
  end

  def blessings
    @blessings ||= blessing_names.map{|n| [n, @analysis.aspects[n]] }.to_h
  end

  def deity_score(deity_name)
    bonus_score @deities[deity_name]
  end

  def primary_score
    bonus_score @node["country"]
  end

  def secondary_score
    bonus_score @node["country_as_secondary"]
  end

  def unknown_keys_warning!
    known_keys = %W[
      allowed_center_conversion
      allowed_conversion
      aspects
      aspects_name
      blessings
      can_have_secondary_religion
      color
      country
      country_as_secondary
      date
      flag_emblem_index_range
      flags_with_emblem_percentage
      harmonized_modifier
      heretic
      hre_heretic_religion
      hre_religion
      icon
      fetishist_cult
      misguided_heretic
      on_convert
      personal_deity
      province
      uses_isolationism
      uses_karma
      uses_piety
      uses_anglican_power
      uses_hussite_power
      uses_church_power
      will_get_center
      holy_sites
    ]
    unknown_keys = @node.keys - known_keys

    unless unknown_keys.empty?
      puts "#{name} - #{unknown_keys.join(", ")}"
    end
  end

  def incomplete?
    %W[
      catholic
      confucianism
      inti
      mesoamerican_religion
      nahuatl
      orthodox
      reformed
      sikhism
    ].include?(name)
  end

  def each_school_bonus
    # This is not directly in game files, just in event that lets you pick school when you change religion to Muslim
    sunni_schools = ["hanafi_school", "hanbali_school", "maliki_school", "shafii_school"]
    shiite_schools = ["ismaili_school", "jafari_school", "zaidi_school"]
    group.each_school_bonus do |school_name, school_bonus|
      if name == "sunni"
        next unless sunni_schools.include?(school_name)
      end
      if name == "shiite"
        next unless shiite_schools.include?(school_name)
      end
      yield(school_name, school_bonus)
    end
  end

  def each_variant
    # Tengri
    if has_secondary?
      @analysis.religions.each do |secondary_name, secondary_religion|
        next if secondary_name == name
        yield(
          "#{localization(name)} + #{localization(secondary_name)}",
          secondary_religion.secondary_score
        )
      end
      return
    end

    # Hindu, Norse
    if has_deities?
      deities.each do |deity_name, deity|
        yield(
          "#{localization(name)} + #{localization(deity_name)}",
          primary_score + deity_score(deity_name)
        )
      end
      return
    end

    # Shinto
    if uses_isolationism?
      @analysis.isolationism.each do |level_name, level_number, bonus|
        yield(
          "#{localization(name)} + #{localization(level_name)} (#{level_number})",
          primary_score + bonus_score(bonus)
        )
      end
      return
    end

    # Buddhist variants
    if uses_karma?
      @analysis.karma.each do |karma_name, karma_bonus|
        yield(
          "#{localization(name)} + #{localization(karma_name)}",
          primary_score + bonus_score(karma_bonus)
        )
      end
      return
    end

    # Islam
    # assume uses_piety and religious_schools belong together,
    # otherwise I'd need to have complex recursion setup here
    if uses_piety?
      each_school_bonus do |school_name, school_bonus|
        @analysis.piety.each do |piety_name, piety_bonus|
          yield(
            "#{localization(name)} + #{localization(school_name)} + #{localization(piety_name)}",
            primary_score + bonus_score(school_bonus) + bonus_score(piety_bonus)
          )
        end
      end
      return
    end

    # Anglican (except it does nothing), Protestant, Hussite
    if uses_aspects?
      best_3 = aspects.map{|an,a| [bonus_score(a), an] }.sort.reverse.first(3)
      best_3_score = best_3_score = best_3.map(&:first).sum
      best_3_names = best_3.map(&:last).map{|n| " + #{localization(n)}" }.join
      yield(
        "#{localization(name)}#{best_3_names}",
        primary_score + best_3_score
      )
      return
    end

    # Coptic
    if uses_blessings?
      best_blessings = blessings.map{|bn,b| [bonus_score(b), bn] }.sort.reverse
      (0..best_blessings.size).each do |i|
        best_score = best_blessings[0, i].map(&:first).sum
        best_names = best_blessings[0, i].map(&:last).map{|n| " + #{localization(n)}" }.join
        yield(
          "#{localization(name)}#{best_names}",
          primary_score + best_score
        )
      end
      return
    end

    # Fetishism
    if fetishist_cult?
      @analysis.cults.each do |cult_name, cult_bonus|
        yield(
          "#{localization(name)} + #{localization(cult_name)}",
          primary_score + bonus_score(cult_bonus)
        )
      end
      return
    end

    # Default - Jewish, Zoroastrian, Animist, Totemism
    yield(localization(name), primary_score)
  end

  def localization(q)
    @analysis.localization(q)
  end
end

class AnalyzeReligions < EU4Analysis
  attr_reader :religions, :piety, :karma, :isolationism, :cults, :aspects

  def initialize(*)
    super
    @groups = {}
    @religions = {}
    @isolationism = []
    @karma = {}
    @piety = {}
    @cults = {}
    @aspects = {}
  end

  def parse_static_bonuses
    parse("common/religions/00_religion.txt").each do |group_name, group_node|
      group = @groups[group_name] = ReligionGroup.new(group_name, group)

      group_node.each do |religion_name, religion|
        next unless religion.is_a?(PropertyList)
        if religion_name == "religious_schools"
          group.religious_schools = religion
          next
        end

        @religions[religion_name] = Religion.new(self, group, religion_name, religion)
      end
    end
  end

  def parse_deity
    glob("common/personal_deities/*.txt").each do |path|
      parse(path).each do |deity_name, deity|
        bonuses = {}
        deity.each do |k, v|
          next if %W[ai_will_do sprite allow].include?(k)
          bonuses[k] = v
        end
        deity["allow"].each do |k,v|
          raise unless k == "religion"
          @religions[v].deities[deity_name] = bonuses
        end
      end
    end
  end

  def parse_isolationism
    glob("common/isolationism/*.txt").each do |path|
      parse(path).each do |level_name, level|
        @isolationism << [level_name, level["isolation_value"], level["modifier"]]
      end
    end
  end

  def parse_cults
    glob("common/fetishist_cults/*.txt").each do |path|
      parse(path).each do |cult_name, cult|
        bonuses = {}
        cult.each do |k, v|
          next if %W[ai_will_do sprite allow].include?(k)
          bonuses[k] = v
        end
        @cults[cult_name] = bonuses
      end
    end
  end

  def parse_static_modifiers
    node = parse("common/static_modifiers/00_static_modifiers.txt")
    @karma["karma_just_right"] = node["karma_just_right"]
    @karma["karma_too_high"] = node["karma_too_high"]
    @karma["karma_too_low"] = node["karma_too_low"]
    @piety["positive_piety"] = node["positive_piety"]
    @piety["negative_piety"] = node["negative_piety"]
  end

  # Anglican are one-off and are not scored!
  def parse_aspects
    glob("common/church_aspects/*.txt").each do |path|
      parse(path).each do |aspect_name, aspect|
        @aspects[aspect_name] = aspect["modifier"]
      end
    end
  end

  def each_religion_varinat
    @religions.each do |religion_name, religion|
      religion.each_variant do |variant_name, score|
        yield(score, variant_name, religion.incomplete?)
      end
    end
  end

  def call
    parse_static_bonuses
    parse_deity
    parse_isolationism
    parse_static_modifiers
    parse_cults
    parse_aspects

    results = []
    each_religion_varinat do |score, name, incomplete|
      results << [score, name, incomplete]
    end

    puts ""
    results.sort.reverse.each do |score, name, incomplete|
      puts("#{"%.6f" % score.round(6)} - #{name}" + (incomplete ? " [INCOMPLETE]" : ""))
    end
  end
end

AnalyzeReligions.new_from_argv.call
