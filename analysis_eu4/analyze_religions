#!/usr/bin/env ruby

require_relative "./eu4_analysis"
require_relative "bonus_scoring"

def bonus_score(bonuses)
  score = BonusScoring.new
  bonuses.each do |k,v|
    score.send(k,v)
  end
  score.score
end

class ReligionGroup
  attr_reader :name, :node
  attr_accessor :religions, :religious_schools

  def initialize(name, node)
    @name = name
    @node = node
    @religions = []
    @religious_schools = nil
  end

  def uses_religious_schools?
    !@religious_schools.empty?
  end

  # Not all are actually pickable, and most countries just start with one
  def each_school_bonus
    @religious_schools.each do |school_name, school|
      bonuses = {}
      school.each do |k, v|
        next if %W[
          potential_invite_scholar
          can_invite_scholar
          on_invite_scholar
          invite_scholar_modifier_display
          picture
        ].include?(k)
        bonuses[k] = v
      end
      yield school_name, bonuses
    end
  end
end

class Religion
  attr_reader :group, :name, :node
  attr_accessor :deities

  def initialize(group, name, node)
    @group = group
    @name = name
    @node = node
    @deities = {}
    unknown_keys_warning!
  end

  def has_religious_schools?
    @group.uses_religious_schools?
  end

  def uses_piety?
    !!@node["uses_piety"]
  end

  def has_secondary?
    @node["can_have_secondary_religion"]
  end

  def uses_isolationism?
    !!@node["uses_isolationism"]
  end

  def uses_karma?
    !!@node["uses_karma"]
  end

  def has_deities?
    !@deities.empty?
  end

  def fetishist_cult?
    !!@node["fetishist_cult"]
  end

  def aspects
    @node["aspects"]
  end

  def uses_aspects?
    !!aspects
  end

  def blessings
    @node["blessings"]
  end

  def uses_blessings?
    !!blessings
  end

  def deity_score(deity_name)
    bonus_score @deities[deity_name]
  end

  def primary_score
    bonus_score @node["country"]
  end

  def secondary_score
    bonus_score @node["country_as_secondary"]
  end

  def unknown_keys_warning!
    known_keys = %W[
      allowed_center_conversion
      allowed_conversion
      aspects
      aspects_name
      blessings
      can_have_secondary_religion
      color
      country
      country_as_secondary
      date
      flag_emblem_index_range
      flags_with_emblem_percentage
      harmonized_modifier
      heretic
      hre_heretic_religion
      hre_religion
      icon
      fetishist_cult
      misguided_heretic
      on_convert
      personal_deity
      province
      uses_isolationism
      uses_karma
      uses_piety
      uses_anglican_power
      uses_hussite_power
      uses_church_power
      will_get_center
      holy_sites
    ]
    unknown_keys = @node.keys - known_keys

    unless unknown_keys.empty?
      puts "#{name} - #{unknown_keys.join(", ")}"
    end
  end

  def each_school_bonus
    # This is not directly in game files, just in event that lets you pick school when you change religion to Muslim
    sunni_schools = ["hanafi_school", "hanbali_school", "maliki_school", "shafii_school"]
    shiite_schools = ["ismaili_school", "jafari_school", "zaidi_school"]
    group.each_school_bonus do |school_name, school_bonus|
      if name == "sunni"
        next unless sunni_schools.include?(school_name)
      end
      if name == "shiite"
        next unless shiite_schools.include?(school_name)
      end
      yield(school_name, school_bonus)
    end
  end
end

class AnalyzeIdeaGroups < EU4Analysis
  def initialize(*)
    super
    @groups = {}
    @religions = {}
    @isolationism = []
    @karma = {}
    @piety = {}
    @cults = {}
    @aspects = {}
  end

  def parse_static_bonuses
    parse("common/religions/00_religion.txt").each do |group_name, group_node|
      group = @groups[group_name] = ReligionGroup.new(group_name, group)

      group_node.each do |religion_name, religion|
        next unless religion.is_a?(PropertyList)
        if religion_name == "religious_schools"
          group.religious_schools = religion
          next
        end

        @religions[religion_name] = Religion.new(group, religion_name, religion)
      end
    end
  end

  def parse_deity
    glob("common/personal_deities/*.txt").each do |path|
      parse(path).each do |deity_name, deity|
        bonuses = {}
        deity.each do |k, v|
          next if %W[ai_will_do sprite allow].include?(k)
          bonuses[k] = v
        end
        deity["allow"].each do |k,v|
          raise unless k == "religion"
          @religions[v].deities[deity_name] = bonuses
        end
      end
    end
  end

  def parse_isolationism
    glob("common/isolationism/*.txt").each do |path|
      parse(path).each do |level_name, level|
        @isolationism << [level_name, level["isolation_value"], level["modifier"]]
      end
    end
  end

  def parse_cults
    glob("common/fetishist_cults/*.txt").each do |path|
      parse(path).each do |cult_name, cult|
        bonuses = {}
        cult.each do |k, v|
          next if %W[ai_will_do sprite allow].include?(k)
          bonuses[k] = v
        end
        @cults[cult_name] = bonuses
      end
    end
  end

  def parse_static_modifiers
    node = parse("common/static_modifiers/00_static_modifiers.txt")
    @karma["karma_just_right"] = node["karma_just_right"]
    @karma["karma_too_high"] = node["karma_too_high"]
    @karma["karma_too_low"] = node["karma_too_low"]
    @piety["positive_piety"] = node["positive_piety"]
    @piety["negative_piety"] = node["negative_piety"]
  end

  # Anglican are one-off and are not scored!
  def parse_aspects
    glob("common/church_aspects/*.txt").each do |path|
      parse(path).each do |aspect_name, aspect|
        @aspects[aspect_name] = aspect["modifier"]
      end
    end
  end

  def incomplete_religions
    %W[
      catholic
      confucianism
      inti
      mesoamerican_religion
      nahuatl
      orthodox
      reformed
      sikhism
    ]
  end

  def each_religion
    @religions.each do |religion_name, religion|
      # Tengri
      if religion.has_secondary?
        @religions.each do |secondary_name, secondary_religion|
          next if secondary_name == religion_name
          yield(
            "#{localization(religion_name)} + #{localization(secondary_name)}",
            secondary_religion.secondary_score
          )
        end
        next
      end

      # Hindu, Norse
      if religion.has_deities?
        religion.deities.each do |deity_name, deity|
          yield(
            "#{localization(religion_name)} + #{localization(deity_name)}",
            religion.primary_score + religion.deity_score(deity_name)
          )
        end
        next
      end

      # Shinto
      if religion.uses_isolationism?
        @isolationism.each do |level_name, level_number, bonus|
          yield(
            "#{localization(religion_name)} + #{localization(level_name)} (#{level_number})",
            religion.primary_score + bonus_score(bonus)
          )
        end
        next
      end

      # Buddhist variants
      if religion.uses_karma?
        @karma.each do |karma_name, karma_bonus|
          yield(
            "#{localization(religion_name)} + #{localization(karma_name)}",
            religion.primary_score + bonus_score(karma_bonus)
          )
        end
        next
      end

      # Islam
      # assume uses_piety and religious_schools belong together,
      # otherwise I'd need to have complex recursion setup here
      if religion.uses_piety?
        religion.each_school_bonus do |school_name, school_bonus|
          @piety.each do |piety_name, piety_bonus|
            yield(
              "#{localization(religion_name)} + #{localization(school_name)} + #{localization(piety_name)}",
              religion.primary_score + bonus_score(school_bonus) + bonus_score(piety_bonus)
            )
          end
        end
        next
      end

      # Anglican (except it does nothing), Protestant, Hussite
      if religion.uses_aspects?
        available_aspects = religion.aspects.select{|a| @aspects[a]}
        best_3 = available_aspects.map{|a| [bonus_score(@aspects[a]), a] }.sort.reverse.first(3)
        best_3_score = best_3_score = best_3.map(&:first).sum
        best_3_names = best_3.map(&:last).map{|n| " + #{localization(n)}" }.join
        yield(
          "#{localization(religion_name)}#{best_3_names}",
          religion.primary_score + best_3_score
        )
        next
      end

      # Coptic
      if religion.uses_blessings?
        best_blessings = religion.blessings.map{|bn| [bonus_score(@aspects[bn]), bn] }.sort.reverse
        (0..best_blessings.size).each do |i|
          best_score = best_blessings[0, i].map(&:first).sum
          best_names = best_blessings[0, i].map(&:last).map{|n| " + #{localization(n)}" }.join
          yield(
            "#{localization(religion_name)}#{best_names}",
            religion.primary_score + best_score
          )
        end
        next
      end

      # Fetishism
      if religion.fetishist_cult?
        @cults.each do |cult_name, cult_bonus|
          yield(
            "#{localization(religion_name)} + #{localization(cult_name)}",
            religion.primary_score + bonus_score(cult_bonus)
          )
        next
        end
      end

      # Default - Jewish, Zoroastrian, Animist, Totemism
      yield(localization(religion_name), religion.primary_score)
    end
  end

  def call
    parse_static_bonuses
    parse_deity
    parse_isolationism
    parse_static_modifiers
    parse_cults
    parse_aspects

    results = []
    each_religion do |name, score|
      results << [score, name]
    end

    puts ""
    incomplete_list = incomplete_religions.map{|n| localization(n)}
    results.sort.reverse.each do |score, name|
      puts("#{"%.6f" % score.round(6)} - #{name}" + (incomplete_list.include?(name) ? " [INCOMPLETE]" : ""))
    end
  end
end

AnalyzeIdeaGroups.new_from_argv.call
